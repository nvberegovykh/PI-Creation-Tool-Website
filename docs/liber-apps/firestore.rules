rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function isSignedIn() { return request.auth != null; }
    function connData(connId) { return get(/databases/$(database)/documents/chatConnections/$(connId)).data; }
    function isInConnData(data) {
      return isSignedIn() && (
        (data.participants != null && request.auth.uid in data.participants) ||
        (data.users != null && request.auth.uid in data.users) ||
        (data.memberIds != null && request.auth.uid in data.memberIds) ||
        (data.key != null && data.key.matches('(^|.*\\|)' + request.auth.uid + '(\\|.*|$)'))
      );
    }
    // Helper: true if current user is a participant of chatConnections/{connId}
    function isParticipant(connId) {
      return isSignedIn() &&
        connId != null &&
        exists(/databases/$(database)/documents/chatConnections/$(connId)) &&
        isInConnData(connData(connId));
    }
    function isAdmin() {
      return isSignedIn() &&
        exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    // Users: public read for directory; write own; admin can manage
    match /users/{userId} {
      allow read: if true;
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update, delete: if (isSignedIn() && request.auth.uid == userId) || isAdmin();
    }

    // Per-user Invoice data (owner-only access)
    match /users/{uid}/invoiceProviders/{docId} {
      allow read, create, update, delete: if isSignedIn() && request.auth.uid == uid;
    }

    match /users/{uid}/invoiceClients/{docId} {
      allow read, create, update, delete: if isSignedIn() && request.auth.uid == uid;
    }

    match /users/{uid}/invoiceServices/{docId} {
      allow read, create, update, delete: if isSignedIn() && request.auth.uid == uid;
    }

    match /users/{uid}/invoices/{docId} {
      allow read, create, update, delete: if isSignedIn() && request.auth.uid == uid;
    }

    match /users/{uid}/invoiceMeta/{docId} {
      allow read, create, update, delete: if isSignedIn() && request.auth.uid == uid;
    }

    // Public E2EE keys
    match /userPublicKeys/{uid} {
      allow read: if true;
      allow create, update: if isSignedIn() && request.auth.uid == uid;
    }

    // Chat connections
    match /chatConnections/{connId} {
      allow create: if isSignedIn() && (
        (request.resource.data.participants != null && request.auth.uid in request.resource.data.participants) ||
        (request.resource.data.users != null && request.auth.uid in request.resource.data.users) ||
        (request.resource.data.memberIds != null && request.auth.uid in request.resource.data.memberIds)
      );
      allow read, update, delete: if isInConnData(resource.data) || isAdmin();
    }

    // Chat messages
    match /chatMessages/{connId}/messages/{msgId} {
      allow read: if isParticipant(connId) || isAdmin();
      allow create: if isParticipant(connId) && request.resource.data.sender == request.auth.uid;
      allow update, delete: if (isParticipant(connId) && resource.data.sender == request.auth.uid) || isAdmin();
    }

    // WebRTC signaling (offers/answers/candidates)
    // Each signaling doc must include connId referencing chatConnections/{connId}
    match /calls/{callId}/{subcollection=**} {
      // Allow participants to write (offers/answers/candidates) â€“ must include connId in payload
      allow write: if (request.resource.data.connId != null && isParticipant(request.resource.data.connId)) || isAdmin();
      // Allow authenticated clients to read signaling docs even before they exist (resource == null)
      // This avoids permission-denied on initial onSnapshot listeners before the first write
      allow read: if isSignedIn() || isAdmin();
    }

    // Posts with likes and comments
    match /posts/{postId} {
      allow read: if resource.data.visibility == 'public' || (isSignedIn() && resource.data.authorId == request.auth.uid) || isAdmin();
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update, delete: if isSignedIn() && resource.data.authorId == request.auth.uid || isAdmin();

      match /likes/{likeUid} {
        allow read: if true;
        allow create: if isSignedIn() && likeUid == request.auth.uid;
        allow delete: if isSignedIn() && likeUid == request.auth.uid || isAdmin();
      }

      match /comments/{commentId} {
        allow read: if true;
        allow create: if isSignedIn() && (
          request.resource.data.authorId == request.auth.uid ||
          request.resource.data.userId == request.auth.uid
        );
        allow update, delete: if isSignedIn() && (
          resource.data.authorId == request.auth.uid ||
          resource.data.userId == request.auth.uid
        ) || isAdmin();
      }

      match /reposts/{repostUid} {
        allow read: if true;
        allow create: if isSignedIn() && repostUid == request.auth.uid;
        allow delete: if isSignedIn() && repostUid == request.auth.uid || isAdmin();
      }
    }

    // Gallery projects and project items
    // Public read for published; owner can read own (drafts); admin can read all
    match /galleryProjects/{projectId} {
      allow read: if resource.data.isPublished == true
                  || (isSignedIn() && resource.data.ownerId == request.auth.uid)
                  || isAdmin();
      allow create: if isSignedIn() && (
        request.resource.data.ownerId == request.auth.uid || isAdmin()
      );
      allow update, delete: if isSignedIn() && (
        resource.data.ownerId == request.auth.uid || isAdmin()
      );

      match /items/{itemId} {
        allow read: if resource.data.isPublished == true
                    || (isSignedIn() && resource.data.ownerId == request.auth.uid)
                    || isAdmin();
        allow create: if isSignedIn() && (
          request.resource.data.ownerId == request.auth.uid || isAdmin()
        );
        allow update, delete: if isSignedIn() && (
          resource.data.ownerId == request.auth.uid || isAdmin()
        );
      }
    }

    // Asset likes (media/file likes in chat and dashboard)
    match /assetLikes/{assetKey}/likes/{likeUid} {
      allow read: if true;
      allow create: if isSignedIn() && likeUid == request.auth.uid;
      allow delete: if isSignedIn() && likeUid == request.auth.uid || isAdmin();
    }

    // Subscriptions (follow graph)
    match /subscriptions/{uid}/following/{targetUid} {
      allow read: if isSignedIn() && request.auth.uid == uid;
      allow create: if isSignedIn() && request.auth.uid == uid;
      allow delete: if isSignedIn() && request.auth.uid == uid || isAdmin();
    }

    // Stable social connections (Personal Space -> Connections)
    match /connections/{uid}/peers/{peerUid} {
      function isOwner() { return isSignedIn() && request.auth.uid == uid; }
      // Requester can create mirrored pending request in receiver subtree:
      // connections/{receiverUid}/peers/{requesterUid}
      function isMirroredPendingCreate() {
        return isSignedIn() &&
          peerUid == request.auth.uid &&
          request.resource.data.status == 'pending' &&
          request.resource.data.requestedBy == request.auth.uid &&
          request.resource.data.requestedTo == uid;
      }
      // Receiver can update mirrored pending request in requester subtree:
      // connections/{requesterUid}/peers/{receiverUid}
      function isMirroredPendingAccept() {
        return isSignedIn() &&
          peerUid == request.auth.uid &&
          resource.data.status == 'pending' &&
          resource.data.requestedTo == request.auth.uid &&
          resource.data.requestedBy == uid &&
          request.resource.data.status == 'connected';
      }
      // Either participant can remove the mirrored row where they are peerUid.
      function isMirrorDeleteByPeer() {
        return isSignedIn() && peerUid == request.auth.uid;
      }

      allow read: if isOwner() || isAdmin();
      allow create: if isOwner() || isAdmin() || isMirroredPendingCreate();
      allow update: if isOwner() || isAdmin() || isMirroredPendingAccept();
      allow delete: if isOwner() || isAdmin() || isMirrorDeleteByPeer();
    }

    // Admin broadcast read channel used by dashboard force-reload listener.
    match /admin/{docId} {
      allow read: if isSignedIn();
      allow write: if isAdmin();
    }

    // Wave (audio) and videos lists
    match /wave/{docId} {
      allow read: if true;
      allow create: if isSignedIn() && request.resource.data.owner == request.auth.uid;
      allow update, delete: if isSignedIn() && resource.data.owner == request.auth.uid || isAdmin();
    }
    match /videos/{docId} {
      allow read: if true;
      allow create: if isSignedIn() && request.resource.data.owner == request.auth.uid;
      allow update, delete: if isSignedIn() && resource.data.owner == request.auth.uid || isAdmin();
    }

    // Shared playlists (WaveConnect)
    match /playlists/{playlistId} {
      allow read: if resource.data.visibility == 'public'
                  || (isSignedIn() && resource.data.ownerId == request.auth.uid)
                  || isAdmin();
      allow create: if isSignedIn()
                    && request.resource.data.ownerId == request.auth.uid;
      allow update: if isSignedIn()
                    && resource.data.ownerId == request.auth.uid
                    || isAdmin();
      // Delete for all: author (owner) or admin only.
      allow delete: if isSignedIn()
                    && resource.data.ownerId == request.auth.uid
                    || isAdmin();
    }

    match /callRooms/{connId} {
      allow read: if isSignedIn();
      allow create, update: if isParticipant(connId) || isAdmin();
    }

    match /callRooms/{connId}/peers/{peerUid} {
      allow read: if isSignedIn();
      allow create, update: if isSignedIn() && request.auth.uid == peerUid && isParticipant(connId) || isAdmin();
      allow delete: if isSignedIn() && request.auth.uid == peerUid && isParticipant(connId) || isAdmin();
    }
  }
}
